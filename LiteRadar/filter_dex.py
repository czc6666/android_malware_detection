# coding=utf-8
from ._settings import *
import json
from .literadar import LibRadarLite
import datetime
from multiprocessing import Pool



# 在要打印的内容前添加时间后打印
def time_print(string):
    time = datetime.datetime.now()
    print(time.strftime("%Y-%m-%d %H:%M:%S") + ' : ' + str(string))



def literadar(apk_file, _3rd_file_path, log_info):  # 使用LiteRadar过滤dex文件
    # 输入：apk文件路径，3rd文件路径，日志信息
    time_print(log_info + ' ' + apk_file)  # 打印日志信息
    try:
        iron_apk_path = apk_file  # 输入apk文件路径
        # print('开始初始化LibRadarLite对象')
        lrd = LibRadarLite(iron_apk_path)  # 初始化LibRadarLite对象
        # print('开始比较')
        res = lrd.compare()  # 比较
        # print('开始写入3rd文件')
        fo = open(_3rd_file_path, 'w+')  # 打开3rd文件
        # print('开始将结果转换为json格式')
        result = json.dumps(res, indent=4, sort_keys=True)  # 将结果转换为json格式
        # print('开始写入3rd文件')
        fo.write(result)  # 写入3rd文件
        # print('开始关闭3rd文件')
        fo.close()  # 关闭3rd文件
    except Exception as e:
        time_print(apk_file + ' ' + str(e))

        # 删除出错的apk文件
        os.remove(apk_file)
        print('!!!!!已删除：', apk_file)

def filter_dex(apk_path, result_path, total_process):  # 过滤dex文件
    global error_apk_list
    error_apk_list = []  # 重置列表
    
    apk_files = os.listdir(apk_path)  # 获取apk文件列表
    
    size_dict = {}  # 用于存储apk文件大小
    for apk_file in apk_files:  # 遍历apk文件列表
        size = os.path.getsize(apk_path + apk_file)  # 获取apk文件大小
        size_dict[apk_file] = size  # 存储apk文件大小

    # 按大小顺序排序，保证大文件先处理，尽量减少最后处理大文件导致时间开销大
    apk_files = [i[0] for i in sorted(size_dict.items(), key=lambda L: L[1], reverse=True)]

    pool = Pool(processes = total_process)  # 创建进程池
    for i in range(len(apk_files)):  # 遍历apk文件列表
        # TODO remove  
        # if i > 5:
        #     break
        filename = apk_files[i]  # 获取apk文件名
        apk_file = apk_path + apk_files[i]  # 获取apk文件路径

        if filename.endswith('.apk'):  # 如果apk文件名以.apk结尾
            _3rd_filename = filename[:-4]  # 通过切片获取3rd文件名
        else:
            _3rd_filename = filename  # 如果apk文件名不以.apk结尾，则3rd文件名与apk文件名相同
        if os.path.exists(result_path+_3rd_filename+'.3rd'):  # 如果3rd文件已存在，则跳过
            continue
        log_info = apk_path + ' already filter: ' + str(i + 1) + ', total : ' + str(len(apk_files))  # 记录日志信息
        # literadar(apk_file, result_path + _3rd_filename + '.3rd', log_info)

        # print('开始执行literadar函数')
        pool.apply_async(literadar, (apk_file, result_path + _3rd_filename + '.3rd', log_info))  # 异步执行literadar函数
        # if (i + 1) % 100 == 0:
        #     time_print()
        # literadar(apk_file,result_path + _3rd_filename + '.3rd', log_info)
    pool.close()  # 关闭进程池
    pool.join()  # 等待所有进程完成


# if __name__ == '__main__':
#     apk_path = '/data2/android_malware_detection/dataset/Androzoo/white/'
#     result_path = '/data2/android_malware_detection/3rd/Androzoo/white/'
#     filter_dex(apk_path, result_path)


