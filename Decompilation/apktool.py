# coding=utf-8
# 导入操作系统相关功能的模块
import os
# 导入高级文件操作模块
import shutil
# 导入子进程管理模块，用于执行系统命令
import subprocess
# 导入日期时间处理模块
import datetime
# 从多进程模块中导入进程池类
from multiprocessing import Pool

# 定义一个函数，在打印内容前添加当前时间
def time_print(string):    # 获取当前时间
    time = datetime.datetime.now()    # 打印格式化的时间和传入的字符串
    print(time.strftime("%Y-%m-%d %H:%M:%S") + ' : ' + str(string))

# 定义单个apk文件反编译的函数
def apktool_single(out_path, filename, apk_file, dex_path):  # 输入：apk文件路径、输出目录、文件名、dex文件路径
    # 构建apktool命令，指定输出目录和文件名，并禁用资源和源码的反编译，强制使用Manifest.xml
    jar_command = 'apktool d --force-manifest --no-res --no-src -o ' + out_path + '/' + filename + '/ ' + apk_file  # 反编译出：xml、dex文件

    child = subprocess.Popen(jar_command, shell=True)  # 使用子进程执行apktool命令
    # 等待子进程完成
    child.wait()

    result_path = out_path + filename  # 构建结果路径
    if not os.path.exists(result_path):  # 如果结果路径不存在
        return  # 返回

    for this_file in os.listdir(result_path):  # 遍历结果目录中的所有文件和文件夹
        if os.path.isfile(result_path + '/' + this_file):  # 如果是文件
            # 如果是AndroidManifest.xml，保留不动
            if "AndroidManifest.xml" == this_file:  # 如果是AndroidManifest.xml文件
                continue  # 跳过处理
            elif this_file.endswith(".dex"):  # 如果是.dex文件
                if not os.path.exists(dex_path + filename):  # 如果dex文件夹不存在，则创建
                    os.mkdir(dex_path + filename)  # 创建dex文件夹
                shutil.move(result_path + '/' + this_file, dex_path + filename + '/' + this_file)  # 移动dex文件到dex文件夹
            else:  # 如果是其他文件
                os.remove(result_path + '/' + this_file)  # 删除其他文件
        else:  # 如果是目录
            try:  # 尝试删除目录
                shutil.rmtree(result_path + '/' + this_file)  # 删除目录
            except Exception as e:  # 捕获异常
                print(e)  # 打印异常信息
                print("shutil retree error: " + result_path)  # 打印错误信息

# 定义使用apktool工具进行反编译的主函数
def apktool(apk_path, out_path, dex_path, total_process):  # 输入：apk文件路径、输出目录、dex文件路径、进程数
    apk_files = os.listdir(apk_path)  # 获取apk文件列表
    
    # 创建字典存储文件大小
    size_dict = {}  # 创建字典存储文件大小
    for apk_file in apk_files:  # 遍历apk文件列表
        size = os.path.getsize(apk_path + apk_file)  # 获取文件大小
        size_dict[apk_file] = size  # 将文件名和文件大小存储到字典
    apk_files = [i[0] for i in sorted(size_dict.items(), key=lambda L: L[1], reverse=True)]  # 按文件大小降序排序

    pool = Pool(processes = total_process)  # 创建进程池
    # 遍历所有apk文件
    for i in range(len(apk_files)):  # 遍历apk文件列表
        # 每处理100个文件打印一次进度
        if (i + 1) % 100 == 0:  # 如果处理了100个文件
            time_print(apk_path + ' already decompile: ' + str(i+1) + ', total : ' + str(len(apk_files)))  # 打印进度
        filename = apk_files[i]  # 获取文件名
        apk_file = apk_path + apk_files[i]  # 构建apk文件路径
        # 如果文件名不以.apk结尾，重命名
        if not filename.endswith('.apk'):  # 如果文件名不以.apk结尾
            os.rename(apk_file, apk_file + '.apk')  # 重命名
            apk_file = apk_file + '.apk'  # 更新apk文件路径
            filename = filename + '.apk'  # 更新文件名
            print("rename: " + apk_file)  # 打印重命名信息
        # 如果输出目录已存在，跳过处理
        if os.path.exists(out_path + '/' + filename):  # 如果输出目录已存在
            time_print("File already unpacked: " + out_path + '/' + filename)  # 打印已解包信息
            continue  # 跳过处理

        pool.apply_async(apktool_single,(out_path, filename, apk_file, dex_path,))  # 异步执行单个apk文件的反编译

    pool.close()  # 关闭进程池
    pool.join()  # 等待进程池中的所有进程完成
