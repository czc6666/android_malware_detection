# coding=utf-8
'''
    2.main_preprocess_python3.py中调用
    使用jadx对每个class.dex进行反编译，并将反编译的全部java文件打包生成.zip的压缩包
    反编译的代码存放在java_src_tmp_path下，最后将java_src_tmp_path下的全部src/文件夹打包成zip文件，存放在java_path下
'''
import os
# import shutil
import subprocess
import time
from multiprocessing import Pool
import signal
# jar_path = '/home/audr/syc_disk/syc/AndroZoo_white/Androzoo_white_4_dex/'
# java_path = '/home/audr/syc_disk/syc/AndroZoo_white/Androzoo_white_4_java/'


def jar2java(jar_path, java_path, java_src_tmp_path, program_root, total_process):  # 反编译主函数
    # jar_path: class.dex存放文件夹，java_path: java压缩包存放位置，
    # java_src_tmp_path: 临时存放反编译后src/文件夹的位置（设置在固态硬盘上，提高IO速度）
    # program_root: 用于在该部分执行完成后将当前路径还原到程序根目录下
    # 每个文件先在java_src_tmp_path下解压得到src文件夹，删除src/resources后，打包成.zip放在java_path下，防止java_path下碎文件太多，影响IO速度
    if not os.path.exists(java_src_tmp_path):  # 如果java_src_tmp_path不存在
        os.system("mkdir -p " + java_src_tmp_path)  # 创建java_src_tmp_path
    os.chdir(java_src_tmp_path)  # 切换到java_src_tmp_path
    pool = Pool(processes=total_process)  # 创建进程池
    filenames = sorted(os.listdir(jar_path), reverse=True)  # 获取jar_path下的文件列表，并按文件名排序

    size_dict = {}  # 用于存储文件大小
    for apk_file in filenames:  # 遍历文件列表
        size = 0  # 初始化文件大小
        parent = jar_path + apk_file + '/'  # 构建父路径
        for file_ in os.listdir(parent):  # 遍历父路径下的所有文件
            size += os.path.getsize(parent + file_)  # 累加文件大小

        size_dict[apk_file] = size  # 将文件大小存储到size_dict中
    # 按大小顺序排序，保证大文件先处理，尽量减少最后处理大文件导致时间开销大
    filenames = [i[0] for i in sorted(size_dict.items(), key=lambda L: L[1], reverse=True)]  # 按文件大小排序

    # print(filenames)
    # raise Exception
    for filename in filenames:
        # jar2java_single(jar_path, java_path, java_src_tmp_path, filename)
        pool.apply_async(jar2java_single, (jar_path, java_path, java_src_tmp_path, filename))  # 异步执行jar2java_single   
    pool.close()  # 关闭进程池
    pool.join()  # 等待所有进程完成
    os.chdir(program_root)  # 切换到程序根目录


def jar2java_single(jar_path, java_path, java_src_tmp_path, filename):  # 单个文件反编译，
    # jar_path: class.dex存放文件夹，java_path: java压缩包存放位置，java_src_tmp_path: 临时存放反编译后src/文件夹的位置

    if os.path.exists(java_path + filename + '.zip'):  # 如果java_path下存在filename.zip文件
        print('File already exist: ' + java_path + filename + '.zip')  # 打印文件已存在
        return  # 返回
    if not os.path.exists(jar_path + filename + '/classes.dex'):  # 如果jar_path下不存在filename/classes.dex文件
        print("step over :" + filename)  # 打印跳过文件
        return  # 返回
    # 在java_src_tmp_path下新建文件夹filename，用于临时存filename反编译出来的java代码
    new_java_src_tmp_path = java_src_tmp_path + '/' + filename  # 构建新路径

    if not os.path.exists(new_java_src_tmp_path):  # 如果新路径不存在
        os.mkdir(new_java_src_tmp_path)  # 创建新路径
    os.chdir(new_java_src_tmp_path)  # 切换到新路径
    if not os.path.exists('src'):  # 如果src目录不存在
        os.mkdir('src')  # 创建src目录

    os.system("rm -rf src/*")  # 删除src目录下的所有文件    
    print("step in :" + filename)  # 打印进入文件

    # 在固态硬盘上的路径java_src_tmp_path里反编译
    for _class in os.listdir(jar_path + filename):  # 遍历jar_path+filename目录下的所有文件
        print('jadx -d src ' + jar_path + filename + '/' + _class)  # 打印jadx命令
        jar_command = 'jadx -d src ' + jar_path + filename + '/' + _class  # 构建jadx命令

        # 部分反编译会卡死，设置超时时间为1小时，大于该时长，则打算反编译后直接打包
        try:
            child = subprocess.Popen(jar_command, shell=True)  # 使用子进程执行jadx命令
            (msg, errs) = child.communicate(timeout=3600)  # 等待子进程完成
            ret_code = child.poll()  # 获取子进程返回码
            child.wait()  # 等待子进程完成
        except subprocess.TimeoutExpired:  # 如果超时
            child.kill()  # 杀死子进程
            child.terminate()  # 终止子进程
        except Exception as e:  # 捕获异常
            pass  # 跳过

    # 将反编译里的resource文件夹删掉
    jar_command = 'rm -rf src/resources'  # 构建删除resources命令
    child = subprocess.Popen(jar_command, shell=True)  # 使用子进程执行命令
    child.wait()  # 等待子进程完成
    # 将反编译的代码打包成zip文件，存在java_path中
    jar_command = 'zip -r ' + java_path + filename + '.zip src'  # 构建zip命令
    child = subprocess.Popen(jar_command, shell=True)  # 使用子进程执行命令
    child.wait()  # 等待子进程完成
    os.system("rm -rf src/")  # 删除src目录
    os.chdir(java_src_tmp_path)  # 切换到java_src_tmp_path
    os.system("rm -rf " + filename)  # 删除filename目录