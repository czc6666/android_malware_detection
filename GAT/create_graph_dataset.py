# coding=utf-8
import sys
import os
import json
import xml.etree.ElementTree as etree
sys.path.append('..')
from lsi.read_data import read_filetype_old_name
from static import get_project_root, get_dataset_name
from czc.dataset_clean.clean_label_from_apkset import clean_label
import time


def create_graph_files(filelist_file, graph_file_root, feature_file_root, output_dir, lsi_feature_file, permission_feature_path=None, type='cscg', apktool_root_path='', add_root=False):
    global error_apk_list  # czc: 全局变量，用于存储错误apk列表
    error_apk_list = []  # czc: 初始化为空列表
    
    index = 0
    count_nodes = 0
    graph_A = []
    graph_indicator = []
    node_attributes = []
    graph_labels = []
    node_labels = []

    filelist, atype = read_filetype_old_name(filelist_file)
    out_file_prefix = filelist_file.split('/')[-1][:-7]

    if not os.path.exists(output_dir):
        os.system('mkdir -p ' + output_dir)


    # 全局的lsi特征，作为根节点
    lsi_features = load_root_feature(lsi_feature_file)

    # permission_feature_path不为空，则表示要生成graph_attributes文件
    if not permission_feature_path is None:
        permission_features = []
        print('Start transform permission features: ' + filelist_file)
        count = 0
        for filename in filelist:
            fi = open(permission_feature_path + filename + '.permission', 'r')
            permission_feature = fi.readline().strip().replace(' ', ', ')
            permission_features.append(permission_feature)
            fi.close()
            count += 1
            if count % 100 == 0:
                print('Already read permission files count: ' + str(count))
        fo = open(output_dir + out_file_prefix + '_graph_attributes.txt', 'w+')
        for permission_feature in permission_features:
            fo.write(permission_feature + '\n')
        fo.close()

    # 保存边信息A
    fo_A = open(output_dir + out_file_prefix + '_A.txt', 'w+')
    # # 保存节点归属关系indicator
    # fo_graph_indicator = open(output_dir + out_file_prefix + '_graph_indicator.txt', 'w+')
    # # 保存图的标签
    # fo_graph_labels = open(output_dir + out_file_prefix + '_graph_labels.txt', 'w+')
    # 保存节点的特征
    fo_node_attributes = open(output_dir + out_file_prefix + '_node_attributes.txt', 'w+')

    for i in range(len(filelist)):
        filename = filelist[i]
        # if filename != 'Apkpure/white/66c86d020ed958cafa8477c649267abb.466c228a5b.apk':
        #     continue
        if atype[i] == 'w':
            graph_labels.append(-1)
        else:
            graph_labels.append(1)
        # 传入时候去掉filename末尾的.apk
        lsi_feature = lsi_features[filename]
        node_count, node_names, edge_list, node_feature = load_graph_and_feature(graph_file_root, feature_file_root, filename[:-4], lsi_feature, type, add_root=add_root)
        for i in range(node_count):
            node_name = node_names[i]
            # mainDir zhongde class zhiwei 1, fouze wei 0
            mainDir = extractMainDir(apktool_root_path, filename)
            # print(node_names)
            if node_name.startswith(mainDir):
                node_labels.append(1)
            else:
                node_labels.append(0)
            graph_indicator.append(index)
            node_attribute_line = str(node_feature[node_name])[1:-1] + '\n'
            fo_node_attributes.write(node_attribute_line)
            # node_attributes.append(node_feature[node_name])
        for edge in edge_list:
            node0 = edge[0]
            node1 = edge[1]
            edge_line = str(count_nodes + node0) + ', ' + str(count_nodes + node1) + '\n'
            fo_A.write(edge_line)
            # graph_A.append((count_nodes + node0, count_nodes + node1))
        index += 1
        count_nodes += node_count

        print('read file done: ' + filename + ', graph_labels count: ' + str(len(graph_labels)) + ', total: ' + str(len(filelist)) + ', total nodes: ' + str(count_nodes) + ', total edges: ' + str(len(graph_A)))
        # raise Exception

    fo_A.close()
    fo_node_attributes.close()

    # # 保存边信息A
    # fo = open(output_dir + out_file_prefix + '_A.txt', 'w+')
    # for edge in graph_A:
    #     line = str(edge[0]) + ', ' + str(edge[1]) + '\n'
    #     fo.write(line)
    # fo.close()

    # 保存节点归属关系indicator
    fo = open(output_dir + out_file_prefix + '_graph_indicator.txt', 'w+')
    for indicator in graph_indicator:
        line = str(indicator) + '\n'
        fo.write(line)
    fo.close()

    # 保存图的标签
    fo = open(output_dir + out_file_prefix + '_graph_labels.txt', 'w+')
    for label in graph_labels:
        line = str(label) + '\n'
        fo.write(line)
    fo.close()

    # # 保存节点的特征
    # fo = open(output_dir + out_file_prefix + '_node_attributes.txt', 'w+')
    # for node_attribute in node_attributes:
    #     # 去掉转成str后的[和]
    #     line = str(node_attribute)[1:-1] + '\n'
    #     fo.write(line)
    # fo.close()

    if type == 'cscg':
        # 保存节点的biaoqian
        fo = open(output_dir + out_file_prefix + '_node_labels.txt', 'w+')
        for node_label in node_labels:
            line = str(node_label) + '\n'
            fo.write(line)
        fo.close()

    if error_apk_list:  # czc: 如果error_apk_list不为空，则表示有错误apk
        print('\n❗❗❗❗❗❗❗发现存在问题的APK文件：')
        error_file = get_project_root() + '错误apk：4main_error_apks.txt'
        with open(error_file, 'w') as f:
            for apk in error_apk_list:
                print(apk)
                f.write(apk + '\n')
        
        print(f'\n❗❗❗❗❗❗❗问题APK文件列表已保存至：{error_file}')
        user_input = 'y'  # input('\n是否要删除这些问题APK文件？(y/n): ')
        
        if user_input.lower() == 'y':  # czc: 如果用户输入为y，则删除问题apk
            deleted_count = 0
            for apk in error_apk_list:
                apk_path = os.path.join(apktool_root_path, apk)
                try:
                    if os.path.exists(apk_path):
                        os.remove(apk_path)
                        deleted_count += 1
                except Exception as e:
                    print(f"删除 {apk} 时出错: {str(e)}")
            
            print(f'\n❗❗❗❗❗❗❗成功删除 {deleted_count}/{len(error_apk_list)} 个问题APK文件')
        
        print('\n❗❗❗❗❗❗❗开始重新清理标签文件')
        time.sleep(3)
        clean_label(get_dataset_name())  # czc: 删除错误apk后，重新清理标签文件
        print('\n❗❗❗❗❗❗❗重新清理标签文件完成')

# 读取每个graph根节点的特征值，即apk文件整体的lsi特征，存在model/lsi/<dataset>/lsi_result(_test).txt里
def load_root_feature(feature_file):
    feature = {}
    fi = open(feature_file)
    while True:
        lines = fi.readlines(10000)
        if not lines:
            break
        for line in lines:
            parts = line.strip().split(',')
            feature[parts[0]] = [float(tk) for tk in parts[2].split(' ')]
    return feature

def load_graph_and_feature(graph_file_root, feature_file_root, filename, lsi_feature, type='cscg', add_root=False):
    # print(lsi_feature)
    # print(feature_file_root)
    index = 0
    node_list = []
    edge_list = []
    node_feature = {}

    _filename = filename.split('/')[-1]
    if type == 'cscg':
        graph_file = graph_file_root + filename.replace(_filename, 'filter-cscg-' + _filename)
        # print(filename, graph_file)
        # raise Exception
    else:
        print('Only support cscg, not include ' + type + '!')
    feature_file = feature_file_root + _filename + feature_type(type)
    # print(feature_file)
    # raise Exception

    # 没有graph文件，则返回单节点
    if not os.path.exists(graph_file) or not os.path.exists(feature_file):
        dimension = get_feature_dimension(feature_file_root, type)
        print(feature_file)
        print('Feature dimension: ' + str(dimension))
        node_list.append('0')
        node_feature[0] = [0.0 for i in range(dimension)]
        index += 1
    else:
        print(graph_file)
        texts = load_graph(graph_file)
        node_feature = load_feature(feature_file)
        root_key = '!!!root'
        if add_root:
            node_feature[root_key] = lsi_feature
            node_list, index, status = append_node_list(node_list, index, root_key)
            # TODO
            root_values = set()
            for key in node_feature:
                root_values.add(key)
            root_values.remove(root_key)

        for key in texts:
            if key not in node_list:
                node_list, index, status = append_node_list(node_list, index, key)
                if status == False:
                    continue
                # if key in root_values:
                #     root_values.remove(key)
                # print(texts[key])
            for node in texts[key]:
                if add_root:
                    if node in root_values:
                        root_values.remove(node)
                if node not in node_list:
                    node_list, index, status = append_node_list(node_list, index, node)
                else:
                    status = True
                if key != node and status == True:
                    edge_list.append((node_list.index(key), node_list.index(node)))
        for key in node_feature:
            if key not in node_list:
                # print(key)
                node_list, index, status = append_node_list(node_list, index, key)
                if status == False:
                    continue
        if add_root:
            for value in root_values:
                edge_list.append((node_list.index(root_key), node_list.index(value)))
            print('no father node: ', len(root_values))
    return index, node_list, edge_list, node_feature


# 将key添加到node_list中，返回添加后的node_list, index，以及状态为True；
# 限制node_list的上限为max，index超过max则不添加，并返回状态为False
def append_node_list(node_list, index, key, max=2001):
    if index < max:
        node_list.append(key)
        index += 1
        return node_list, index, True
    else:
        # raise Exception
        return node_list, index, False




def get_feature_dimension(feature_file_root, type):
    files = os.listdir(feature_file_root)
    for _file in files:
        if _file.endswith(feature_type(type)):
            feature_dict = load_feature(feature_file_root + _file)
            if not feature_dict == {}:
                key = list(feature_dict.keys())[0]
                return len(feature_dict[key])


def feature_type(type):
    if type == 'cscg':
        feature_file = '.lsiClassSet'
    else:
        feature_file = '.lsiJava'
    return feature_file


def load_graph(graph_file):
    fi = open(graph_file, 'r')
    line = fi.readline().strip()
    fi.close()
    texts = json.loads(line)
    return texts


def load_feature(feature_file):
    fi = open(feature_file, 'r')
    feature_dict = {}
    for line in fi.readlines():
        _line = line.strip()
        feature_string = _line.split(',')[-1]
        features = feature_string.split(' ')
        key = _line[:-(len(feature_string) + 1)]
        feature_dict[key] = [float(i) for i in features]
    return feature_dict


def extractMainDir(apktool_root_path, filename):
    global error_apk_list
    
    manifest_file = apktool_root_path + 'manifest/' + filename + '/AndroidManifest.xml'
    package = ''
    if os.path.exists(manifest_file):
        try:
            tree = etree.ElementTree(file=manifest_file)
            root = tree.getroot()
            package = root.attrib['package']
        except Exception as e:
            print(f"Error occurred in {filename}: {str(e)}")
            if filename not in error_apk_list:
                error_apk_list.append(filename)
    else:
        print('No such file: ' + manifest_file)
        if filename not in error_apk_list:
            error_apk_list.append(filename)
    mainDir = package
    return mainDir
