import os
import zipfile
from datetime import datetime
import shutil
import sys
# 一行添加上上级目录
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
from static import get_project_root


def backup_code():
    """
    函数说明文档：
    备份代码到root主目录，忽略LiteRadar/Data/Decompiled目录，
    备份文件名：czc_AMD_backup_{当前日期}.zip
    """

    # 源代码目录
    source_dir = get_project_root() + '/code'
    
    # 要忽略的目录和文件
    ignore_dirs = [
        get_project_root() + '/code/android_malware_detection/LiteRadar/Data/Decompiled',
        get_project_root() + '/code/android_malware_detection/tools'
    ]
    ignore_files = [
        get_project_root() + '/code/android_malware_detection/log_libradar.txt'
    ]
    
    # 获取当前日期作为文件名的一部分
    current_date = datetime.now().strftime('%Y%m%d_%H%M%S')
    backup_name = f'czc_AMD_backup_{current_date}.zip'
    
    # 创建临时目录用于存放备份文件
    temp_dir = os.path.expanduser('~/backup_temp')
    if not os.path.exists(temp_dir):
        os.makedirs(temp_dir)
    
    backup_path = os.path.join(temp_dir, backup_name)
    
    try:
        print(f"开始备份代码到: {backup_path}")
        
        # 创建 ZIP 文件
        with zipfile.ZipFile(backup_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            # 遍历源目录
            for root, dirs, files in os.walk(source_dir):
                # 检查当前目录是否是要忽略的目录
                if any(ignore_dir in root for ignore_dir in ignore_dirs):
                    continue
                
                # 获取相对路径
                rel_path = os.path.relpath(root, source_dir)
                
                # 添加文件到 ZIP
                for file in files:
                    # 跳过 .pyc 文件和其他不需要的文件
                    if file.endswith(('.pyc', '.pyo', '.pyd', '.so')):
                        continue
                    
                    file_path = os.path.join(root, file)
                    # 检查是否是要忽略的文件
                    if file_path in ignore_files:
                        continue
                        
                    arc_name = os.path.join(rel_path, file)
                    print(f"添加文件: {arc_name}")
                    zipf.write(file_path, arc_name)
        
        # 计算备份文件大小
        backup_size = os.path.getsize(backup_path)
        print(f"\n备份完成!")
        print(f"备份文件: {backup_path}")
        print(f"文件大小: {backup_size / 1024 / 1024:.2f} MB")
        
        # 将备份文件移动到用户的主目录
        final_path = os.path.expanduser(f'~/{backup_name}')
        shutil.move(backup_path, final_path)
        print(f"备份文件已移动到: {final_path}")
        
    except Exception as e:
        print(f"备份过程中出现错误: {str(e)}")
    finally:
        # 清理临时目录
        if os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)

if __name__ == '__main__':
    backup_code()